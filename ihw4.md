# ИДЗ #4
# Фролов Иван Григорьевич, БПИ-235

## Задание No 4 Разработка многопоточных приложений

### Задание (Вариант 31):
**Задача о Пути Кулака.** На седых склонах Гималаев стоит древ- ний буддистский монастырь: Гуань-Инь-Янь. Каждый год в день сошествия на землю боддисатвы монахи монастыря собираются на совместное празднество и показывают свое совершенствование на Пути Кулака. Всех соревнующихся монахов первоначально разби- вают на пары. Бои продолжаются до выявления победителя. Мо- нах который победил в финальном бою, забирает себе на хранение статую боддисатвы. Реализовать многопоточное приложение, опре- деляющего победителя. В качестве входных данных используется массив, в котором хранится количество энергии Ци каждого мо- наха. При победе монах забирает энергию Ци своего противника. Новые пары образуются среди победителей других пар в порядке завершения поединков. То есть, возможна ситуация, когда бойцы, участвующие в поединке могут быстро победить и начать биться с другими, в то время как поединки начавшиеся ранее, могут продол- жаться. Причем длительное время. Каждый поединок протекает некоторое случайное время, которое пропорционально отношению энергии Ци побежденного к энергии Ци победитея, умноженному на поправочный коэффициент, позволяющий отслеживать проте- кание поединка на экране дисплея (например, путем умножения этого отношения на 1000 миллисекунд или другое более удобное значение).


### Запуск программы

Программа запускается с использованием `Makefile` командой:  

`make run QI="10 30 20 40" OUTPUT="output.txt" INPUT="input.txt"` 

Исходный код лежит в файле `main.cpp`   

Ключи:  

`QI`: Список энергий Ци монахов, разделенных пробелами. Если передан, игнорируется файл INPUT.  
`INPUT`: Путь к конфигурационному файлу, содержащему значения энергий Ци монахов. Используется, если не задан QI.  
`OUTPUT`: Путь к выходному файлу для записи результатов турнира. Если не указан, результаты выводятся только в консоль.

### Примечание

Постарался сделать все на 10 баллов!

В архиве папке есть три пары файлов ввода / вывода для тестов.  
`input.txt` и `output.txt`.  
`input1.txt` и `output1.txt`.  
`input2.txt` и `output2.txt`.  

### Сценарий задачи в терминах предметной области

В буддийском монастыре проходит турнир между монахами, демонстрирующими свои навыки Пути Кулака. 

Каждый монах обладает определенной энергией Ци, которая используется в бою. Турнир организован следующим образом:  

Монахи делятся на пары случайным образом.
Каждый поединок длится время, пропорциональное энергии проигравшего монаха.  
Победитель в поединке забирает энергию Ци побежденного монаха.  
После завершения всех поединков текущего раунда победители снова делятся на пары, и цикл продолжается.    
Турнир заканчивается, когда остается один победитель, который становится хранителем статуи боддисатвы.  

### Модель параллельных вычислений
Для симуляции поединков используется многопоточная модель:

Каждый поединок происходит в отдельном потоке, что моделирует независимость сражений между парами монахов.  

**Потоки синхронизируются с использованием мьютексов:**  
print_mutex: Защищает вывод в консоль, чтобы результаты поединков не перемешивались.  
tournament_mutex: Используется для управления общим состоянием турнира.  
После завершения всех потоков текущего раунда собираются победители, которые участвуют в следующем раунде.  

### Обобщенный алгоритм  
Инициализация:  
Чтение данных о монахах из командной строки (QI) или файла (INPUT).  
Создание структуры данных для монахов, содержащей их ID и энергию Ци.  

Перемешивание участников:  
В каждом раунде монахи случайным образом разбиваются на пары. Если количество участников нечетное, один монах автоматически переходит в следующий раунд.  

Симуляция поединков:  
Для каждой пары создается поток, который моделирует бой между монахами.  
Победитель забирает энергию Ци побежденного.  
Результаты записываются в консоль и, при наличии файла OUTPUT, в него.  

Переход в следующий раунд:  
После завершения текущего раунда собираются победители, которые участвуют в следующем раунде.  

Завершение турнира:  
Турнир продолжается до тех пор, пока не останется один победитель.  
Итоговый результат выводится в консоль и записывается в файл (если указан).  

### Задание на 9 баллов  

Оно запускается командой 

`make runBarrier QI="10 30 20 40" OUTPUT="output.txt" INPUT="input.txt"`  

Исходный код лежит в файле `mainBarrier.cpp`  

Отличия от первой программы:  

**Использование барьеров (pthread_barrier_t):**   
Все матчи раунда должны завершиться, прежде чем начать следующий раунд.  
Это гарантирует синхронизацию между потоками.  

**Условные переменные (pthread_cond_t):**  
Используются для уведомления об окончании раунда.  
Потоки ждут завершения раунда через условную переменную.  

**Устранены мьютексы для управления турниром, их заменил барьеры и условные переменные.**  

Примечание: сравнительный анализ был проведен, результат получается идентичный первой программе.  

### Задание на 10 баллов  

Используем OpenMP.

Чтобы все работало, сначала необходимо установить OpenMP: `brew install llvm libomp`(это комаанда для MacOS)  

После этого в файле `CMakeLists.txt` раскомментировать строчки  
 
`#add_executable(mainOMP mainOMP.cpp)` и 
`# include_directories("/opt/homebrew/opt/libomp/include")`  

Далее запускаем с помощью make:

`make runOMP QI="10 30" OUTPUT="output.txt" INPUT="input.txt"`  

Исходный код лежит в файле `mainOMP.cpp`   


### Тестовые прогоны (скриншоты)
<img width="426" alt="image" src="https://github.com/user-attachments/assets/baab3c7f-78fb-4240-b5bd-d98d8d9c58a7">  
<img width="436" alt="image" src="https://github.com/user-attachments/assets/f098e917-3b3c-4207-9ece-3b20d542e07b">  
<img width="421" alt="image" src="https://github.com/user-attachments/assets/bba36fad-da64-4b23-bd0e-df20527cc1dd">  
<img width="444" alt="image" src="https://github.com/user-attachments/assets/5f9298e8-b29e-4a3f-a3a9-e215e24f0275">  
